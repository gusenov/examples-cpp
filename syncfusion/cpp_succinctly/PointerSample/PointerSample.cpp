#include <memory>

// #define NDEBUG 1
#include <cassert>

#include "../pchar.h"

using namespace std;

void SetValueToZero(int& value) { value = 0; }
void SetValueToZero(int* value) { *value = 0; }

int _pmain(int /*argc*/, _pchar* /*argv*/[]) {
  int value = 0;
  const int intArrCount = 20;

  // Создание указателя на int:
  int* p_intArr = new int[intArrCount];

  //---------------------------------------------------------------------

  // Создание константного указателя на int:
  int* const cp_intArr = p_intArr;

  // Следующие две строки допустимы поскольку мы можем модифицировать данные
  // на которые указывает константный указатель:

  // Присвоить всем элементам значение 5:
  uninitialized_fill_n(cp_intArr, intArrCount, 5);

  // Присвоить первому элементу 0:
  *cp_intArr = 0;

  // Эта инструкция недопустима поскольку нельзя модифицировать на что
  // указывает константный указатель:
  // cp_intArr = nullptr;

  //---------------------------------------------------------------------

  // Создание указателя на const int:
  const int* pc_intArr = nullptr;

  // Допустимо, т.к. можно модифицировать на что указывает указатель на
  // константу:
  pc_intArr = p_intArr;

  // "Используем" pc_intArr:
  value = *pc_intArr;

  // Эта инструкция недопустима поскольку нельзя модифицировать данные на
  // которые указывает указатель на константу:
  // *pc_intArr = 10;

  //---------------------------------------------------------------------

  const int* const cpc_intArr = p_intArr;

  // Следующие две инструкция недопустимы поскольку нельзя модифицировать на
  // что указывает константный указатель на константу и нельзя модифицировать
  // данные на которые он указывает:
  // cpc_intArr = p_intArr;
  // *cpc_intArr = 20;

  // "Используем" cpc_intArr:
  value = *cpc_intArr;

  //---------------------------------------------------------------------

  *p_intArr = 6;
  SetValueToZero(*p_intArr);

  // Из заголовочного файл <cassert>, этот макрос покажет диагностическое
  // сообщение, если выражение в скобках вычислится как что-то другое, а не ноль.
  // В отличиее от макроса _ASSERTE, этот будет запускаться и в Release builds.
  // Чтобы отключить его, нужно определить NDEBUG перед подключением
  // заголовочного файла <cassert>:
  assert(*p_intArr == 0);

  //---------------------------------------------------------------------

  *p_intArr = 9;
  int& r_first = *p_intArr;
  SetValueToZero(r_first);
  assert(*p_intArr == 0);

  //---------------------------------------------------------------------

  const int& cr_first = *p_intArr;

  // Эта инструкция недопустима поскольку cr_first это константная ссылка,
  // а SetValueToZero не принимает константную ссылку, SetValueToZero принимает
  // только non-const ссылку, что имеет смысл поскольку функция модифицирует
  // значение:
  // SetValueToZero(cr_first);

  value = cr_first;

  //---------------------------------------------------------------------

  // Можно инициализировать указатель используя оператор взятия адреса.
  // Следует принять во внимание, что локальные non-static переменные становятся
  // невалидными при выходе из их области видимости поэтому любые указатели
  // на них также станут невалидными:
  int* p_firstElement = &r_first;

  *p_firstElement = 10;
  SetValueToZero(*p_firstElement);
  assert(*p_firstElement == 0);

  //---------------------------------------------------------------------

  // Тут будут вызовы перегруженной функции SetValueToZero(int*) поскольку
  // мы используем оператор взятия адреса для перевода ссылки в указатель:
  SetValueToZero(&r_first);

  *p_intArr = 3;
  SetValueToZero(&(*p_intArr));
  assert(*p_firstElement == 0);

  //---------------------------------------------------------------------

  // Создание указателя на функцию:
  void (*FunctionPtrToSVTZ)(int&) = nullptr;
  // Имя переменной следует занести в скобки со знаком * перед ним.

  // Указатель на функцию будет указывать на SetValueToZero:
  FunctionPtrToSVTZ = &SetValueToZero;
  // Корректная перегрузка будет выбрана автоматически.

  //---------------------------------------------------------------------

  *p_intArr = 20;

  // Вызов функции на которую указывает FunctionPtrToSVTZ,
  // т.е. SetValueToZero(int&):
  FunctionPtrToSVTZ(*p_intArr);

  assert(*p_intArr == 0);

  //---------------------------------------------------------------------

  *p_intArr = 50;

  // Можно также вызвать функцию по указателю следующим образом:
  (*FunctionPtrToSVTZ)(*p_intArr);
  // Это ближе к тому, что фактически происходит за кулисами;
  // FunctionPtrToSVTZ разыменовывается в указываемую функцию, которая затем
  // вызывается используя значения указанные во вторых скобках,
  // т.е. *p_intArr.

  assert(*p_intArr == 0);

  //---------------------------------------------------------------------

  // Устанавливаем value значение 0, чтобы дальше "использовать" его:
  *p_intArr = 0;
  value = *p_intArr;

  // Удалить p_intArray используя оператор delete[] т.к. это динамический
  // p_intArray:
  delete[] p_intArr;
  p_intArr = nullptr;

  return value;
}
