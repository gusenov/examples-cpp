#ifndef A_H
#define A_H

template <typename T>
class A {

public:

  void bar() const {
    // do something and then call foo (possibly) in the derived class:
    foo();
  }

  // Метод A<T>::foo() подобен чистому виртуальному методу в том смысле, что
  // у него нет имплементации по умолчанию и вызовы этого метода направляются
  // производным классам. Однако это не предотвращает инстанцирование класса
  // A<T> как небазового класса. Чтобы этого достичь деструктор A<T>::~A()
  // сделан защищенным.
  void foo() const {
    static_cast<const T*>(this)->foo();
  }

protected:

  ~A() = default;
  // В GCC есть баг, который делает функции-члены публичными когда
  // используется = default;
  // Поэтому в таком случае надо писать:
  // ~A() {}

  // Желательно сделать все конструкторы защищенными (включая конструкторы
  // копирования и перемещения).

};

#endif
