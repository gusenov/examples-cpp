class IDemo
{
  public:

    // ВИРТУАЛЬНЫЙ ДЕСТРУКТОР:

    // This allows you to pass pointer ownership to another party without
    // exposing the concrete derived class.
    virtual ~IDemo() {}

    // Деструктор не должен ничего делать т.к. в интерфейсе нет конкретных
    // членов.


    // Если не нужно удалять класс через базовый класс, то виртуальный
    // деструктор не нужен. Однако никогда не повредит сделать деструктор
    // виртуальным (не считая того, что будет делаться один vtable lookup).

    // Другой вариант. Определить чистый виртуальный (=0) деструктор с телом.
    // Компилятор сможет увидеть, что в vtable сейчас нет валидных членов и
    // откажется от vtable. С виртуальным дестуктором с телом, деструктор
    // может быть вызван (виртуально) в середине конструкции через указатель
    // this (когда сконструированный объект всё еще типа Parent) и поэтому
    // компилятор должен предоставить валидный vtable. Поэтому если не нужно
    // явно вызывать виртуальные деструкторы через this в процессе
    // конструирования, то можно сэкономить на размере кода.

    // Деструктор можно вызвать в середине конструирования, если сделать throw
    // из конструктора производного класса.

    // Рассмотрим иерархию Base <- Derived <- MostDerived. Мы в конструкторе
    // Derived вызываем глобальную функцию, которая принимает аргмент Base*,
    // передавая в неё this. Эта функция может явно вызвать деструктор через
    // указатель и он выполнится виртуально (dispatched virtually):
    // this->~Foo()

    // Это определенно будет UB если мы разрушим объект до того как он
    // закончит конструкцию. Но мы можем разрушить его и больше никогда
    // не возвращаться в конструктор. Например в бесконечном цикле обрабатывая
    // ввод.

    // Есть мало причин для того чтобы не делать деструктор чисто виртуальным.

    // GCC не позволяет чисто виртуальные деструкторы и требует определять их:
    // http://stackoverflow.com/a/3065223/447490
    // Эту проблему можно решить с помощью #ifdef и проверки компилятора.
    // Либо определять виртуальные деструкторы и немного терять в оптимизации.

    //---------------------------------------------------------------------

    // Возможно тут нужны еще чистые виртуальные декларации оператора = и
    // конструктора копирования, чтобы предотвратить их автоматическую
    // генерацию компилятором.

    // Потому что весьма маловероятно, что компилятор автоматически сгенерирует
    // корректно. Поэтому лучше самим определить их явно чисто виртуальными.

    // Интерфейс должен быть очень малой частью класса, который имплементирует
    // интерфейс; в частности он не должен иметь никаких членов данных.
    // В противном случае почти гарантировано сгенерированная компилятором
    // копия и операторы присваивания будут делать неправильные вещи.
    // Поэтому не стоит этого делать.
    // Хотя доступ к интерфейсу и осуществляется через указатель, а с копиями
    // указателя всё ОК, если управлять ownership-ом.

    // Присутствие или отсутствие сгенерированных компилятором
    // присваивания / копирования невозможно обнаружить до тех пор пока они
    // не будут вызваны. Пример: *a = *b

    // К тому же присваивание / копирование интерфейса ничего не делает.


    virtual void OverrideMe() = 0;
};
