class Testable {
  public:
    virtual void test() = 0;

  protected:

    // Интерфейсы в общем не копируемы (copyable) и напрямую не конструируемы.
    // Здесь мы их просто прячем от публичного доступа. Пусть потомки решают.

    Testable();
    // Конструкторы не могут быть виртуальными и синтаксис = 0 применим только
    // к виртуальным методам.

    // Констуктор копирования:
    Testable(const Testable& that);

    // Оператор присваивания:
    Testable& operator= (const Testable& that);

    // Если не объявить конструктор копирования и оператор присваивания
    // защищенными, то тогда они будут публичными по умолчанию. Если они
    // однажды стали публичными, то вниз по иерархии они уже не смогут стать
    // защищенными.

    // Они публичные, но это не те же самые вещи, которые определяются в
    // наследниках. Производные классы могут определить свои как приватные или
    // защищенные.

    // Но в C++11 их можно пометить как "= delete", если нужно запретить
    // копирование или присваивание. Т.е. этот синтаксис говорит, что этот
    // класс не имеет данный метод.

    // Base(const Base&) может быть вызван только из Derived(const Derived&)
    // (пользователь не может сделать этот вызов).
    // Оператор по умолчанию Base& operator = (const Base& b) тоже не может
    // быть вызван.
    // Не стоит придавать value semantics интерфейсам, т.к. их целевое
    // использование имеет reference semantics. Использование value semantics
    // нарушает принцип подстановки Барбары Лисков.

    virtual ~Testable();

    // Такой виртуальный защищенный дестуктор бесполезен. Оно может быть
    // вызван только из производных классов, т.к. он защищенный и поэтому
    // ему не нужно быть виртуальным.
};
