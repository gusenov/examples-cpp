class Testable
{
public:

    virtual ~Testable() { }
    // virtual ~Testable() = default;  // предпочтительнее в C++11

    virtual void test() = 0;
};

// Данное определение не делает выводов о копируемости производных классов.
// Всё о чем оно говорит, что производный класс должен имплементировать test.
// Что и требуется для интерфейса.

// Производные классы могут пометить свои конструкторы копирования как
// private/protected, если им это нужно.

// То что интерфейс копируемый не говорит о том, что объекты тоже копируемы.
// Копирование на уровне интерфейса вызовет slicing и не является хорошей идеей.

// Этот класс невозможно инстанцировать поэтому поэтому не стоит беспокоиться
// о неявных конструкторах т.к. они не могут быть вызваны напрямую через тип
// интерфейса.

// Если нужно заставить производные классы имплементировать деструктор, то
// нужно сделать его чистым (но ему всё равно нужно имплементировать в
// интерфейсе). Деструктор может быть чисто виртуальным.
// Но ему нужно всё равно нужно определение. Но его можно оставить пустым {}.
// pure virtual и definition это не взаимоисключающие вещи.

// Если полиморфная деструкция не нужна, то можно сделать деструктор защищенным
// и невиртуальным.

// =0 говорит о том, что вызвать можно, но должно определение в дочернем классе.
// =delete говорит о том, что вызвать нельзя и будет ошибка если это сделать.
// =delete применимо к любой функции-члену (normal, non-copy и non-move)
// не являющей конструктором или дестуктором.
